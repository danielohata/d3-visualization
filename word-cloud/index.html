<html>
  <head>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>
    <script src="cloud.js"></script>
  </head>
  <body>
    <div id="chart"></div>
    <script>
      var text_string = "Abstract- To play a game well a player needs to understand the game. To defeat an opponent, it may be sufficient to understand the opponent’s weak spots and to be able to exploit them. In human practice, both elements (knowing the game and knowing the opponent) play an important role. This article focuses on opponent modelling independent of any game. So, the domain of interest is a collection of two-person games, multiperson games, and commercial games. The emphasis is on types and roles of opponent models, such as speculation, tutoring, training, and mimicking characters. Various implementations are given. Suggestions for learning the opponent models are described and their realization is illustrated by opponent models in game-tree search. We then transfer these techniques to commercial games. Here it is crucial for a successful opponent model that the changes of the opponent’s reactions over time are adequately dealt with. This is done by dynamic scripting, an improvised online learning technique for games. Our conclusions are (1) that opponent modelling has a wealth of techniques that are waiting for implementation in actual commercial games, but (2) that the games’ publishers are reluctant to incorporate these techniques since they have no definitive opinion on the successes of a program that is outclassing human beings in strength and creativity, and (3) that game AI has an entertainment factor that is too multifaceted to grasp in reasonable time. 1 Introduction Ever since humans play games they desire to master the game played. Obviously, gauging the intricacies of a game completely is a difficult task; understanding some parts is most of the time the best a player can aim at. The latter means solving some sub-domains of a game. However, in a competitive game it may be sufficient to understand more of the game than the opponent does in order to win a combat. Remarkably, here a shift of attention may take place, since playing better than the opponent may happen (1) by the player’s more extensive knowledge of the game or (2) by the player’s knowledge of the oddities of the opponent. In human practice, a combination of (1) and (2) is part of the preparation of a top grandmaster in Chess, Checkers or Shogi. Opponent modelling is an intriguing part of a player’s match preparation, since the preparing player tries to understand the preferences, strategies, skill, and weak spots of his1 opponent. In the following we distinguish between the player and the opponent if a two-person game is discussed. In multi1 In this article we use ‘he’ (‘his’) if both ‘he’ and ‘she’ are possible. person games and in commercial games we will speak of agents. Opponent modelling is a research topic that was envisaged already a long time ago. For instance, in the 1970s chess programs incorporated a contempt factor, meaning that against a stronger opponent a draw was accepted even if the player was +0.5 ahead, and a draw was declined against a weaker opponent even when the player had a minus score. In the 1990s serious research in the domain of opponent modelling started [5, 19]. Nowadays opponent modelling also plays a part in multi-person games (collaboration, conspiracy, opposition) and in commercial games. Here we see a shift from opponent modelling towards subject modelling and even environmental entertainment modelling. The course of the article is as follows. Section 2 defines types and roles of opponent models. In section 3 we provide a brief overview of the development of opponent models currently in use in Roshambo, the Iterated Prisoner’s Dilemma, and Poker. We extrapolate the development to commercial Games. Section 4 lists six possible implementations of the opponent models. A main question is dealt with in section 5, viz. how to learn opponent models. We describe two methods, refer to a third one, and leave the others undiscussed. Section 6 focuses on the three implementations in game-tree search: OM search, PrOM search, and symmetric opponent modelling. Section 7 presents dynamic scripting as a technique for online adaptive game AI in commercial games. Finally section 8 contains our conclusions.";

drawWordCloud(text_string);

function drawWordCloud(text_string){
  var common = "poop,i,me,my,myself,we,us,our,ours,ourselves,you,your,yours,yourself,yourselves,he,him,his,himself,she,her,hers,herself,it,its,itself,they,them,their,theirs,themselves,what,which,who,whom,whose,this,that,these,those,am,is,are,was,were,be,been,being,have,has,had,having,do,does,did,doing,will,would,should,can,could,ought,i'm,you're,he's,she's,it's,we're,they're,i've,you've,we've,they've,i'd,you'd,he'd,she'd,we'd,they'd,i'll,you'll,he'll,she'll,we'll,they'll,isn't,aren't,wasn't,weren't,hasn't,haven't,hadn't,doesn't,don't,didn't,won't,wouldn't,shan't,shouldn't,can't,cannot,couldn't,mustn't,let's,that's,who's,what's,here's,there's,when's,where's,why's,how's,a,an,the,and,but,if,or,because,as,until,while,of,at,by,for,with,about,against,between,into,through,during,before,after,above,below,to,from,up,upon,down,in,out,on,off,over,under,again,further,then,once,here,there,when,where,why,how,all,any,both,each,few,more,most,other,some,such,no,nor,not,only,own,same,so,than,too,very,say,says,said,shall";

  var word_count = {};

  var words = text_string.split(/[ '\-\(\)\*":;\[\]|{},.!?]+/);
  if (words.length == 1){
    word_count[words[0]] = 1;
  } else {
    words.forEach(function(word){
      var word = word.toLowerCase();
      if (word != "" && common.indexOf(word)==-1 && word.length>1){
        if (word_count[word]){
          word_count[word]++;
        } else {
          word_count[word] = 1;
        }
      }
    })
  }

  var svg_location = "#chart";
  var width = $(document).width();
  var height = $(document).height();

  var fill = d3.scale.category20();

  var word_entries = d3.entries(word_count);

  var xScale = d3.scale.linear()
    .domain([0, d3.max(word_entries, function(d) {
      return d.value;
    })
    ])
    .range([10,100]);

  d3.layout.cloud().size([width, height])
    .timeInterval(20)
    .words(word_entries)
    .fontSize(function(d) { return xScale(+d.value); })
    .text(function(d) { return d.key; })
    .rotate(function() { return ~~(Math.random() * 2) * 90; })
    .font("Impact")
    .on("end", draw)
    .start();

  function draw(words) {
    d3.select(svg_location).append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + [width >> 1, height >> 1] + ")")
      .selectAll("text")
      .data(words)
      .enter().append("text")
      .style("font-size", function(d) { return xScale(d.value) + "px"; })
      .style("font-family", "Impact")
      .style("fill", function(d, i) { return fill(i); })
      .attr("text-anchor", "middle")
      .attr("transform", function(d) {
        return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
      })
      .text(function(d) { return d.key; });
  }

  d3.layout.cloud().stop();
}
    </script>
  </body>
</html>
